[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "download-install-r.html",
    "href": "download-install-r.html",
    "title": "Digital Soil Mapping",
    "section": "",
    "text": "This tutorial will teach you how to begin programming with R using RStudio. We’ll install R, and RStudio, a popular development environment for R. We’ll also learn how to install R-package and some key RStudio features to start programming in R on our own.\n\n\n\nR is one of the most popular open-source statistical computing and visualization environments. It was developed in 1980 based on the S-language, and an open-source community regularly updates the software for a robust, programmable, portable, and open-source computing environment. We can use it to solve complex and sophisticated problems and “routine” analysis without restrictions on access or use.\n\n\n\nWe can download R from the R project of a repository CRAN. The version of R to download depends on our operating system. We can also install Microsoft R Open, the enhanced distribution of R from Microsoft. It includes additional capabilities for improved performance and reproducibility and support for Windows and Linux-based platforms.\n\nClick this link to download the latest stable version of R\nSelect a CRAN location (a mirror site) close to you\nClick on the “Download R for Windows”\nClick on the “install R for the first time” link at the top corner of the page\nClick “Download R for Windows” and it will download to local download folder\n\n\n\n\n\nInstallation instruction of R in Windows and MAC could be found here. Detail Installation steps of Microsoft R Open in different operating systems can be found here.\n\n\n\nOpen Windows Explorer\nNavigate to the directory where the downloaded R.4.2.#-win.exe (the latest version) file is exit.\nDouble-click this exe file and follow the instruction as shown in the video below:\n\n\n\n\n\nInstalling R on Mac OS is similar to Windows. The easiest way is to install it through CRAN by going to the CRAN downloads page and following description as as shown here. In brief, download the .pkg and open the .pkg file and follow the standard instructions for installing applications on MAC OS X.\n\n\n\nStep 1: Update and Upgrade the Ubuntu 22.04\nTo update and upgrade packages on Ubuntu 22.04, firstly, open up the terminal by pressing “CTRL+ALT+T” and execute the following command:\n\nsudo apt update\n\n\nsudo apt upgrade\n\nStep 2: Add dependencies\nNow, on your Ubuntu 22.04 system, download and install required dependencies. These dependencies are used to execute the R on Ubuntu 22.04. Run the following command for the specified purpose:\n\nsudo apt install dirmngr gnupg apt-transport-https ca-certificates software-properties-common\n\nStep 3: Authenticate the packages\nAuthenticate the installed packages by writing out the following command:\n\nsudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys E298A3A825C0D65DFD57CBB651716619E084DAB9\n\nStep 4: Import GPG key\nNext, import the GPG key in your system through below command:\n\nwget -O- https://cloud.r-project.org/bin/linux/ubuntu/marutter_pubkey.asc | sudo gpg –dearmor | sudo tee /usr/share/keyrings/cran.gpg\n\nStep 5: Add CRAN repository\nAfter importing the GPG key, you need to add the CRAN repository that is highly recommended for R installation:\n\necho deb [signed-by=/usr/share/keyrings/cran.gpg] https://cloud.r-project.org/bin/linux/ubuntu $(lsb_release -cs)-cran40/ | sudo tee /etc/apt/sources.list.d/cran.list\n\n\nsudo apt update\n\nStep 6: Install R through CRAN repository Now, your Ubuntu 22.04 system is ready to install the R language from the CRAN repository. To do so, type the following command:\n\nsudo apt install r-base\n\n\nsudo apt-get install libcurl4-openssl-dev libssl-dev libxml2-dev liblapack-dev\n\nStep 7: Check R -version\n\nR –version\n\n\n\n\n\nAfter R installation in Windows, double click on the desktop icon or open the program from START to run R. R will be open as a Console window.\n\n\n\nFigure 1: Interface of R-base\n\n\nYou can work in the console and the command line. However, the command line can be pretty daunting to a beginner. It is better to work in R Editor. First, you must create a New script from File menu. Any code you run in R-script output will be displayed in the console window. You can save all your R codes as an R script file and output in the console as an R-Data file.\n\n\n\n\nR can be run in the command line and graphical user interfaces in integrated development environment (IDE). Below are the best programming IDE for R:\n\nRStudio\nR Tools for Visual Studio\nRattle\nESS\nTinn-R\nR AnalyticalFlow\nRadiant\nRBox\nCode\n\n\n\nRStudio is one of the best integrated development environment (IDE) for R that includes a console, a terminal syntax-highlighting editor that supports direct code execution, as well as tools for plotting, history, debugging and workspace management. RStudio Desktop and RStudio Server for Windows, Mac, and Linux are open sources.\nRStudio is now Posit. First, you have to download the latest version of RStudio according to your operating system from here.\n\nFor windows user, and just run the installation file and it normally detects your latest installed R version automatically. If you want to do some extra configuration, you need follow some steps which can be found here\nFor installation instruction of R and RStudio in Mac OS could be found here.\nInstalling R Studio on Ubuntu could be found here\nWe may open RStudio just double click Rstudio icon on your Desktop or on the task bar. The RStudio interface has four main panels:\n\nConsole: where you can type commands and see output.\nScript editor: where you can type out commands and save to file.\nEnvironment/History: environment shows all active objects and history keeps track of all commands run in console.\nFiles/Plots/Packages/Help etc.\n\n\n\n\nFigure 2: RStudio interface\n\n\n\n\n\n\nR Packages are collections of R functions, data, and compiled code in a well-defined format. The directory where packages are stored is called the library. We can install any R ‘package’ or multiple package directly from the console, using r-script and GUI (Tools > Install Packages) through internet.\nUse install.packages() function in your console or in a script:\n\ninstall.packages(“raster”, dependencies = TRUE)\n\nFor multiple packages:\n\ninstall.packages(c(“raster”,“gstat”), dependencies = TRUE)\n\nIf we want see content of any library, just use help() function or package specific:\n\nlibrary(help=spatial)\n\n\n\n\nMarkdown is a lightweight markup language for creating formatted text using a plain-text editor. Markdown is widely used in blogging, instant messaging, online forums, collaborative software, documentation pages, and readme files (wikipedia).\nR Markdown is an excellent platform for data analysis and turns it into a high-quality document, webpage, dashboard, and presentation. It is reproducible and supports multiple languages, including R, Python, and SQL. R Markdown supports dozens of static and dynamic output formats, including HTML, PDF, MS Word, Beamer, HTML5 slides, Tufte-style handouts, books, dashboards, shiny applications, scientific articles, websites, and more. (R Markdown)\nYou can use a single R Markdown file to i) save and execute code and ii) generate high quality reports that can be shared with an audience.\nA brief overview could be found here:\nFor a brief a brief tutorial, please visit here\n\n\n\nFigure 3: R-Markdown Cheat Sheet -1\n\n\n\n\n\nFigure 4: R-Markdown Cheat Sheet -2\n\n\n\n\n\nLike, R Markdown, Quarto is an open-source scientific and technical publishing system built on Pandoc, a universal document converter. It creates dynamic content with Python, R, Julia, and Observablefor publishing high-quality articles, reports, presentations, websites, blogs, and books in HTML, PDF, MS Word, ePub, and more.\nLike R Markdown, Quarto uses Knitr to execute R code. So it can render most existing Rmd files without modification. The difference between R Markdown and Quarto is related to output formats. Quarto includes many more built-in output formats (and more options for customizing each format). Quarto also has native features for particular project types like Websites, Books, and Blogs (rather than relying on external packages).\nTo run Quarto on RStudio, you must install it in your system. You can download it from here according to your operating system. After installation, you need to install the quarto package to render documents from the R console.\n\ninstall.packages(“quarto”)\n\n\nquarto::quarto_render(“hello.qmd”)\n\nAndy Field have series of YouTube video tutorials related to Quarto. Link of these are in below:\nQuarto part 1\nQuarto part 2\nQuarto part 3\nQuarto part 4\nQuarto part 5"
  },
  {
    "objectID": "getting-started-r.html",
    "href": "getting-started-r.html",
    "title": "Digital Soil Mapping",
    "section": "",
    "text": "Getting Started with R\nThe goal of this section is to give you a rapid overview of R and R-Studio installation, and some basic concepts of R and data import/export to/from R.\nThis section consists of three main Chapters:\n\nDownload and Installation R\nIntroduction to Using R"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Digital Soil Mapping",
    "section": "",
    "text": "Digital soil mapping (DSM) is a technique that uses advanced technologies such as remote sensing, geographic information systems (GIS), and statistical modeling to create high-resolution maps of soil properties and characteristics. These maps can be used to support a variety of applications, including land use planning, precision agriculture, natural resource management, and environmental modeling.\nDSM typically involves the collection of soil data from a variety of sources, including soil surveys, soil samples, and remote sensing data such as satellite imagery. This data is then combined and analyzed using a range of statistical and machine learning algorithms to develop predictive models of soil properties, such as soil texture, organic matter content, and nutrient availability.\nThe resulting soil maps are highly detailed and can provide valuable information about soil characteristics at the landscape level, such as soil types, soil health, and soil fertility. This information can be used to optimize crop management practices, evaluate the environmental impacts of land use changes, and support conservation efforts.\nOverall, digital soil mapping is an important tool for understanding the complex interactions between soil, land use, and the environment, and can help support more sustainable and effective land management practices."
  },
  {
    "objectID": "index.html#digital-soil-mapping-in-bangladesh",
    "href": "index.html#digital-soil-mapping-in-bangladesh",
    "title": "Digital Soil Mapping",
    "section": "Digital Soil Mapping in Bangladesh",
    "text": "Digital Soil Mapping in Bangladesh\nIn Bangladesh, DSM has been identified as a priority area for agricultural development and soil resource management.The country has a diverse range of soils, including alluvial, deltaic, and coastal soils, which are highly variable in terms of their physical, chemical, and biological properties. DSM in Bangladesh involves the collection of various soil data, including soil types, soil texture, soil organic matter content, soil pH, soil fertility, and soil moisture. These data are then integrated with digital data on topography, climate, vegetation, and land use to create soil maps and databases.\nDSM in Bangladesh has several benefits, including:\nImproved land use planning: DSM can provide accurate and detailed information on soil properties, which can be used for land use planning and management.\nImproved crop productivity: DSM can provide information on soil fertility, soil moisture, and other factors that can affect crop productivity, helping farmers to make informed decisions about crop selection and management practices.\nConservation of soil resources: DSM can help in identifying areas with soil erosion and degradation issues, leading to the development of conservation strategies.\nImproved agricultural research: DSM can provide valuable information for agricultural research and development.\nOverall, DSM in Bangladesh has the potential to improve agricultural productivity, promote sustainable land use practices, and support soil conservation efforts."
  },
  {
    "objectID": "index.html#digital-soil-mapping-with-r",
    "href": "index.html#digital-soil-mapping-with-r",
    "title": "Digital Soil Mapping",
    "section": "Digital Soil Mapping with R",
    "text": "Digital Soil Mapping with R\nR is an open-source statistical computing and visualization environment. It is based on the S language developed at Bell Laboratories in the 1980s. Now it is one of the most robust, programmable, portable, and open computing environments for data analysis and visualization without any restrictions on access or use.\nAlthough several books and online tutorials are available related to DSM in R, this training-workshop targets national scientists in Bangladesh who have working experience soil science, GIS, and statistics.\nThis training-workshop will covered following lessons:\n\nGetting Started with R\nData Import-Export\nData Wrangling with R\nBasic Statistics\nMultivariate Statistic\nMachine Learning\nSpatial Data Processing\nDigital Terrain Modeling\nRemote Sensing\nSpatial Interpolation\n\nAfter finishing these lessons all participant will work on soil data and will produce digital soil maps of Bangladesh.\nZia U Ahmed, PhD\nResearch Associate Professor (Data & Visualization)\nRENEW (Research and Education in eNergy, Environment and Water) Institute\nUniversity at Buffalo"
  },
  {
    "objectID": "introduction-to-r.html",
    "href": "introduction-to-r.html",
    "title": "Digital Soil Mapping",
    "section": "",
    "text": "R is an object-oriented programming language like Python, Julia, and JavaScript. Like these programming languages, R has a specific syntax or function, which is essential to understand if you want to use its features to accomplish thousands of things with R. However, one of the most challenging parts of learning R is finding your way around. In section of tutorial you will learn some basic of R such as syntax of R programming, assignment statements, r-data types, control statements and simple r-function.\n\n\n\nThe screen prompt > in R-console is an place to put command or instruction for R to work. Press the “Ctrl” + “L” keys simultaneously. The screen will now be refreshed and the console should be cleared.\n\n\n\nFigure 1: R Screen Prompt\n\n\n\n\n\nWe can use R as a calculators, at the prompt, we enter the expression that we want evaluated and when we hit enter, it will compute the result for us . For Example:\nFor addition:\n\n2+2\n\n[1] 4\n\n\nAnd for subtraction:\n\n4-2\n\n[1] 2\n\n\nFor multiplication:\n\n4*2\n\n[1] 8\n\n\nFor raised to the power:\n\n2^2\n\n[1] 4\n\n\nUse parentheses to ensure that it understands what you are trying to compute.\nhttps://www.geeksforgeeks.org/control-statements-in-r-programming/?ref=lbp\n\n\n\nVariables, Comments, and Keywords are the three main components in R- programming. Variables are used to store the data, Comments are used to improve code readability, and Keywords are reserved words that hold a specific meaning to the compiler.\n\n\n\nThere are so many built-in mathematical functions are available in base-R. Some are shown in below table:\n\n\n\nBuilt-in Math Functions\n\n\nHere below some examples of R built-in R-functions\n\nlog10(2)\n\n[1] 0.30103\n\n\n\nexp(1)\n\n[1] 2.718282\n\n\n\npi\n\n[1] 3.141593\n\n\n\nsin(pi/2)\n\n[1] 1\n\n\n\n\n\nWe can use very big numbers or very small numbers in R using the following scheme:\n\n1.2e3 # means 1200 because the e3 means ‘move the decimal point 3 places to the right \n\n[1] 1200\n\n\n\n1.2e-2 # means 0.012 because the e-2 means ‘move the decimal point 2 places to the left’\n\n[1] 0.012\n\n\n\n\n\nSuppose we want to know the integer part of a division: say, how many 13s are there in 119:\n\n119 %/% 13\n\n[1] 9\n\n\nSuppose we wanted to know the remainder (what is left over when 119 is divided by 13: in maths this is known as modulo\n\n119 %% 13\n\n[1] 2\n\n\n\n\n\nSeveral types of rounding (rounding up, rounding down, rounding to the nearest integer) can be done easily with R.\nThe ‘greatest integer less than’ function is floor()\n\nfloor(5.7)\n\n[1] 5\n\n\nThe ‘next integer’ function is ceiling()\n\nceiling(5.7)\n\n[1] 6\n\n\n\n\n\nJust like in algebra, we often want to store a computation under some variable name. The result is assigned to a variable with the symbols = or <- which is formed by the “less than” symbol followed immediately by a hyphen.\n\nx<-10; # or\ny = 12\n\nWhen you want to know what is in a variable simply ask by typing the variable name.\n\nx; # or\n\n[1] 10\n\ny\n\n[1] 12\n\n\nWe can store a computation of two variable names and do some calculation and the result is assigned to a new variable\n\na=2;\nb=3;\nc=a+b;\nc\n\n[1] 5\n\n\n\n\n\n\nDo not begin a variable name with a period or a number. Variable names are case (upper/lower) sensitive.\nVariable names in R are case-sensitive so x is not the same as X.\nVariable names should not begin with numbers (e.g. 1x) or symbols (e.g. %x).\nVariable names should not contain blank spaces: use grain.yield\n\n\n\n\n\n# + - */%% ^ arithmetic\n# > >= < <= == != relational\n# ! & \u0003 logical\n# ~ model formulae\n# <- -> assignment\n# $ list indexing (the ‘element name’ operator)\n# : create a sequence\n\n\n\n\nR has a wide variety of data types including scalars, vectors (numerical, character, logical), matrices, data frames, and lists.\n\n\nVectors is data-type with one or more values of the same type such as logical, integer, real, complex, string (or character) or raw vectors. Unlike Python, the indexing of the vector in R will start from ‘1’ and not from ‘0’.\nA scalar data structure is the most basic data type that holds only a single atomic value at a time. Using scalars, more complex data types can be constructed. The most commonly used scalar types in R:\n\nNumeric\nCharacter or strings\nInteger\nLogical\nComplex\n\nNumeric is the default type used in R for mathematical computations. Examples of numeric are decimal numbers and whole numbers.\n\nx=1.2\nx\n\n[1] 1.2\n\nclass(x)\n\n[1] \"numeric\"\n\n\nCharacter objects are strings. They could be any sequence of characters including alphabets, numbers, punctuation marks, etc. enclosed in quotes.\n\nDepartment = 'Chemistry'\nSchool= \"University at Buffalo\"\nclass(School)\n\n[1] \"character\"\n\npaste(Department,\",\", School)\n\n[1] \"Chemistry , University at Buffalo\"\n\n\nLogical values are boolean values of TRUE or FALSE. Note that R needs logical values of TRUE or FALSE to be in upper case. If you use mixed case or lowercase, you’ll get an error or unpredictable results.\n\nu = TRUE; \nv = FALSE\nclass(u)\n\n[1] \"logical\"\n\nclass(v)\n\n[1] \"logical\"\n\n\nA list of numbers or charterers together to form a Multiple Elements Vector. Values can be assigned to vectors in many different ways. We can create a vector of number from 1 to 10, using the concatenation function c\n\na <- c(1,2,5.3,6,7,8,9,10)\na\n\n[1]  1.0  2.0  5.3  6.0  7.0  8.0  9.0 10.0\n\n\n\ns <- c('apple','red',5,TRUE)\nprint(s)\n\n[1] \"apple\" \"red\"   \"5\"     \"TRUE\" \n\n\nIt can be generated by the sequence of integer values 1 to 10 using : (colon), the sequence-generating operator,\n\na<-1:10\na\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWe can also create a vector using Using sequence (Seq.) operator.\n\n# Create vector with elements from 5 to 9 incrementing by 0.4.\nb = seq(5, 9, by = 0.4)\nb\n\n [1] 5.0 5.4 5.8 6.2 6.6 7.0 7.4 7.8 8.2 8.6 9.0\n\n\nR has ability to evaluate functions over entire vectors, so no need to write , for loops and subscripts. Important vector functions are listed in below Table:\n\n\n\nVector Functions\n\n\nOnce we have a vector of numbers we can apply certain built-in functions to them to get useful summaries. For example:\n\nsum(a)        # sums the values in the vector \n\n[1] 55\n\nlength(a)     # number of the values in the vector \n\n[1] 10\n\nmean (a)      # the average of the values in the vector \n\n[1] 5.5\n\nvar (a)        # the sample variance of the values \n\n[1] 9.166667\n\nsd(a)         # the standard of deviations of the values  \n\n[1] 3.02765\n\nmax(a)        # the largest value in the vector  \n\n[1] 10\n\nmin(a)        # the smallest number in the vector \n\n[1] 1\n\nmedian(a)     # the sample median \n\n[1] 5.5\n\n\nSummary() function will calculate summary statistics of a vector\n\nsummary(a)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    3.25    5.50    5.50    7.75   10.00 \n\n\nTwo vectors of same length can be added, subtracted, multiplied or divided giving the result as a vector output.\n\n# Create two vectors.\nv1 <- c(3,8,4,5,0,11)\nv2 <- c(4,11,0,8,1,2)\n\n\n# Vector addition.\nadd.result <- v1+v2\nprint(add.result)\n\n[1]  7 19  4 13  1 13\n\n\n\n# Vector subtraction.\nsub.result <- v1-v2\nprint(sub.result)\n\n[1] -1 -3  4 -3 -1  9\n\n\n\n# Vector multiplication.\nmulti.result <- v1*v2\nprint(multi.result)\n\n[1] 12 88  0 40  0 22\n\n\n\n# Vector division.\ndivi.result <- v1/v2\nprint(divi.result)\n\n[1] 0.7500000 0.7272727       Inf 0.6250000 0.0000000 5.5000000\n\n\n\n\n\nMatrices is a two-dimensional rectangular layout of number in rows and columns. All columns in a matrix must have the same mode (numeric, character, etc.) and the same length.\nAll columns in a matrix must have the same mode (numeric, character, etc.) and the same length. There are several ways of making a matrix. Suppose you were interested in the matrix of 2 x 3. You could form the two rows (vectors) and then bind (rbind) them together to form the matrix:\n\nr1=c(6,2,10)     # row 1\nr2=c(1,3,-2)     # row 2\nX=rbind(r1,r2)   # binds the vectors into rows a matrix\nX\n\n   [,1] [,2] [,3]\nr1    6    2   10\nr2    1    3   -2\n\nclass(X)\n\n[1] \"matrix\" \"array\" \n\n\nWe can bind them (cbind) the same vectors into columns of a matrix\n\nY=cbind(r1,r2)   \nY\n\n     r1 r2\n[1,]  6  1\n[2,]  2  3\n[3,] 10 -2\n\n\nA Matrix cab be created using the matrix() function from the given set of values. The basic function of a matrix is:\n\nmatrix(data, nrow, ncol, byrow, dimnames)\n\nThe values are:\n\ndata is the input vector which becomes the data elements of the matrix.\nnrow is the number of rows to be created.\nncol is the number of columns to be created.\nbyrow is a logical clue. If TRUE then the input vector elements are arranged by row.\ndimname is the names assigned to the rows and columns.\n\n\nX <- matrix(1:9, nrow = 4, ncol = 3, byrow=T) # row matrix\n\nWarning in matrix(1:9, nrow = 4, ncol = 3, byrow = T): data length [9] is not a\nsub-multiple or multiple of the number of rows [4]\n\nX\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n[3,]    7    8    9\n[4,]    1    2    3\n\n\n\nclass(X)\n\n[1] \"matrix\" \"array\" \n\nattributes(X)\n\n$dim\n[1] 4 3\n\n\nThe class and attributes of X indicate that it is a matrix of four rows and three columns (these are its dim attributes)\nWe can create matrix with row and column names:\n\n# create a vector \ncells=c(1,26,24,68,35,68,73,18,2,56,4,5,34,21,24,20)  # create a vector\n# names of column rows\ncnames = c(\"C1\",\"C2\",\"C3\",\"C4\") \n# names of two rows\nrnames = c(\"R1\",\"R2\",\"R3\",\"R4\") \n# matrix\nZ= matrix(cells,nrow=4, ncol=4, byrow=TRUE,dimnames=list(rnames,cnames))\nZ\n\n   C1 C2 C3 C4\nR1  1 26 24 68\nR2 35 68 73 18\nR3  2 56  4  5\nR4 34 21 24 20\n\n\nOr, we can easily naming the rows and columns of matrices. Suppose we want to labels rows with Trial names, like Trial.1, Trial.2 etc.:\n\nrownames(X)<-rownames(X, do.NULL=FALSE, prefix=\"Trial.\")\nX\n\n        [,1] [,2] [,3]\nTrial.1    1    2    3\nTrial.2    4    5    6\nTrial.3    7    8    9\nTrial.4    1    2    3\n\n\nFor column names, we will create a vector of different names for the three most commonly used drugs used in the trial, and use this to specify the colnames(X):\n\ndrug.names<-c(\"Aspirin\", \"Acetaminophen\", \"Ibuprofen\")\ncolnames(X)<-drug.names\nX\n\n        Aspirin Acetaminophen Ibuprofen\nTrial.1       1             2         3\nTrial.2       4             5         6\nTrial.3       7             8         9\nTrial.4       1             2         3\n\n\nWe can access elements of a matrix using the square bracket [] indexing method. Elements can be accessed as var[row, column]. Here rows and columns are vectors.\n\nX[,2]  # 2nd column of a matrix\n\nTrial.1 Trial.2 Trial.3 Trial.4 \n      2       5       8       2 \n\nX[3,]  # 3rd row of a matrix\n\n      Aspirin Acetaminophen     Ibuprofen \n            7             8             9 \n\n\n\nX[,2:3] # 2nd and 3rd column\n\n        Acetaminophen Ibuprofen\nTrial.1             2         3\nTrial.2             5         6\nTrial.3             8         9\nTrial.4             2         3\n\n\n\nX[2:4,1:2]     # rows 2,3,4 of columns 1 and 2\n\n        Aspirin Acetaminophen\nTrial.2       4             5\nTrial.3       7             8\nTrial.4       1             2\n\n\nWe can use summary() function to get row and column wise summary statistics of a matrix\n\n# summary statistics of each column\nsummary(X)\n\n    Aspirin     Acetaminophen    Ibuprofen   \n Min.   :1.00   Min.   :2.00   Min.   :3.00  \n 1st Qu.:1.00   1st Qu.:2.00   1st Qu.:3.00  \n Median :2.50   Median :3.50   Median :4.50  \n Mean   :3.25   Mean   :4.25   Mean   :5.25  \n 3rd Qu.:4.75   3rd Qu.:5.75   3rd Qu.:6.75  \n Max.   :7.00   Max.   :8.00   Max.   :9.00  \n\n\n\n# summary statistics and mean of the column 1 of matrix\nsummary(X[,1])\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   1.00    1.00    2.50    3.25    4.75    7.00 \n\n# mean\nmean(X[,1])\n\n[1] 3.25\n\n\nCalculated over all the rows and the mean & variance of the bottom row (Trial.4)\n\nmean(X[4,])\n\n[1] 2\n\nvar(X[4,])\n\n[1] 1\n\n\nThere are some special functions for calculating summary statistics on matrices\n\n# Total\nrowSums(X)\n\nTrial.1 Trial.2 Trial.3 Trial.4 \n      6      15      24       6 \n\ncolSums(X)\n\n      Aspirin Acetaminophen     Ibuprofen \n           13            17            21 \n\n\n\n# Mean\nrowMeans(X)\n\nTrial.1 Trial.2 Trial.3 Trial.4 \n      2       5       8       2 \n\ncolMeans(X)\n\n      Aspirin Acetaminophen     Ibuprofen \n         3.25          4.25          5.25 \n\n\nWe can also use apply() function to calculate row and column means. Here columns are margin no. 2 (rows are margin no. 1\n\napply(X,2,mean)\n\n      Aspirin Acetaminophen     Ibuprofen \n         3.25          4.25          5.25 \n\n\n\napply(X,1,mean)\n\nTrial.1 Trial.2 Trial.3 Trial.4 \n      2       5       8       2 \n\n\n\n\n\nFactors are data structures that are implemented to categorize the data or represent categorical data and store it on multiple levels.\nIn R, factor() function create or convert string-vectors to factors:\n\n# string vectors\ngender <- c(rep(\"male\",20), rep(\"female\", 30))\n# define factors\ngender <- factor(gender) # # 1=female, 2=male internally (alphabetically)\n# checking the factors\nprint(is.factor(gender))\n\n[1] TRUE\n\nclass(gender) # \n\n[1] \"factor\"\n\nsummary(gender)\n\nfemale   male \n    30     20 \n\n\n\n\n\nArrays is data storage structures with fixed number of dimensions. An array in R can be created with the use of array() function.\n\narr = array(2:13, dim = c(2, 3, 2))\nprint(arr)\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    2    4    6\n[2,]    3    5    7\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    8   10   12\n[2,]    9   11   13\n\n\nVectors of different lengths can also be fed as input into the array() function\n\nvec1 <- c(1, 2, 3, 4, 5, 6, 7, 8, 9)\nvec2 <- c(10, 11, 12)\n  \n# elements are combined into a single vector, \n# vec1 elements followed by vec2 elements.\narr = array(c(vec1, vec2), dim = c(2, 3, 2))\nprint (arr)\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]    7    9   11\n[2,]    8   10   12\n\n\n\n\n\nList is a one-detrimental data element which consist of several objects in a order. The object in a list may be mixed data types or different data types.The list can be a list of vectors, a list of matrices, a list of characters and a list of functions, and so on.\nlist in R is created with the use of list() function.\n\nmy.list <- list(Location=\"NY\", \n                Year = 2021,\n                LabExp=X) # Lab experimental data\n             \n\nlist(my.list)\n\n[[1]]\n[[1]]$Location\n[1] \"NY\"\n\n[[1]]$Year\n[1] 2021\n\n[[1]]$LabExp\n        Aspirin Acetaminophen Ibuprofen\nTrial.1       1             2         3\nTrial.2       4             5         6\nTrial.3       7             8         9\nTrial.4       1             2         3\n\n\nComponents of a list can be accessed in similar fashion like matrix or data frame:\n\nmy.list[\"LabExp\"]\n\n$LabExp\n        Aspirin Acetaminophen Ibuprofen\nTrial.1       1             2         3\nTrial.2       4             5         6\nTrial.3       7             8         9\nTrial.4       1             2         3\n\nmy.list[\"FieldData\"]\n\n$<NA>\nNULL\n\n\n\n\n\nIn R, tabular data are stored as Data Frame which is made up of three principal components, the data, rows, and columns. It is more general than a matrix, in that different columns can have different modes (numeric, character, factor, etc.).\nTo create a data frame in R use data.frame() command and then pass each of the vectors you have created as arguments to the function\n\nID = c(1,2,3,4)    # create a vector of ID coloumn \nLandcover = c(\"Grassland\",\"Forest\", \"Arable\", \"Urban\") # create a text vector \nSettlement  = c (FALSE, FALSE, FALSE, TRUE) # creates a logical vector\npH   = c(6.6,4.5, 6.8, 7.5)   # create a numerical vector\nSOC  = c (1.2, 3.4, 1.1, 0.12) # create a numerical vector\nmy.df=data.frame(ID,Landcover,Settlement, pH, SOC) # create a data frame\n\nmy.df\n\n  ID Landcover Settlement  pH  SOC\n1  1 Grassland      FALSE 6.6 1.20\n2  2    Forest      FALSE 4.5 3.40\n3  3    Arable      FALSE 6.8 1.10\n4  4     Urban       TRUE 7.5 0.12\n\n\nwe can see the detail of structure using str() function\n\nstr(my.df)\n\n'data.frame':   4 obs. of  5 variables:\n $ ID        : num  1 2 3 4\n $ Landcover : chr  \"Grassland\" \"Forest\" \"Arable\" \"Urban\"\n $ Settlement: logi  FALSE FALSE FALSE TRUE\n $ pH        : num  6.6 4.5 6.8 7.5\n $ SOC       : num  1.2 3.4 1.1 0.12\n\n\n\nhead(my.df)\n\n  ID Landcover Settlement  pH  SOC\n1  1 Grassland      FALSE 6.6 1.20\n2  2    Forest      FALSE 4.5 3.40\n3  3    Arable      FALSE 6.8 1.10\n4  4     Urban       TRUE 7.5 0.12\n\n\n\nsummary(my.df$pH)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  4.500   6.075   6.700   6.350   6.975   7.500 \n\nsummary(my.df[,4:5])\n\n       pH             SOC       \n Min.   :4.500   Min.   :0.120  \n 1st Qu.:6.075   1st Qu.:0.855  \n Median :6.700   Median :1.150  \n Mean   :6.350   Mean   :1.455  \n 3rd Qu.:6.975   3rd Qu.:1.750  \n Max.   :7.500   Max.   :3.400  \n\n\nComponents of data frame can be accessed like a list or like a matrix.\n\nmy.df[\"Landcover\"]\n\n  Landcover\n1 Grassland\n2    Forest\n3    Arable\n4     Urban\n\nmy.df[[2]]\n\n[1] \"Grassland\" \"Forest\"    \"Arable\"    \"Urban\"    \n\nmy.df[,4:5]\n\n   pH  SOC\n1 6.6 1.20\n2 4.5 3.40\n3 6.8 1.10\n4 7.5 0.12\n\n\n\n\n\n\nControl flow is the order in which a statement execute and control statements use to control the execution and flow of the program based on conditions provided in the statements.\nThe eight major types of control statements are follows:\n\nif: statement for conditional programming\nif..else: statement for conditional programming\nfor: loop to iterate over a fixed number of iterations\nwhile: loop to iterate until a logical statement returns FALSE\nrepeat: loop to execute until told to break\nbreak/next:break/next arguments to exit and skip interations in a loop\n\n\n\nIf the expression is true, the statement gets executed. But if the expression is FALSE, nothing happens.\n\nx <- 12\n# condition\nif(x > 10){\nprint(paste(x, \"is greater than 10\"))\n}\n\n[1] \"12 is greater than 10\"\n\n\n\n\n\nIt is similar to if condition but when the test expression in if condition fails, then statements in else condition are executed.\n\nx <- c(3, 3, -2, 1)\n\nif(any(x < 0)){\n        print(\"x contains negative numbers\")\n} else{\n        print(\"x contains all positive numbers\")\n}\n\n[1] \"x contains negative numbers\"\n\n\n\nx <- c(3, 3, 3, 1)\n\nif(any(x < 0)){\n        print(\"x contains negative numbers\")\n} else{\n        print(\"x contains all positive numbers\")\n}\n\n[1] \"x contains all positive numbers\"\n\n\n\n\n\nThe for loop is used to execute repetitive code statements for a particular number of time. It is useful to iterate over the elements of a list, dataframe, vector, matrix, or any other object.\n\nfor (i in 10:15){\n        output <- paste(\"The number is\", i)\n        print(output)\n}\n\n[1] \"The number is 10\"\n[1] \"The number is 11\"\n[1] \"The number is 12\"\n[1] \"The number is 13\"\n[1] \"The number is 14\"\n[1] \"The number is 15\"\n\n\n\n# for loop with vector\nx <- c(-8, 3, 12, 15)\nfor (i in x)\n{\n    print(i)\n}\n\n[1] -8\n[1] 3\n[1] 12\n[1] 15\n\n\n\n\n\nWhile loop executes the same code again and again until a stop condition is met\n\nresult <- 1\ni <- 1\n# test expression\nwhile (i < 5) {\n    print(result)\n# update expression\n   i = i + 1\n   result = result + 1\n}\n\n[1] 1\n[1] 2\n[1] 3\n[1] 4\n\n\nFollowing example show the while statement with break\n\nresult <- 1\ni <- 1\n# test expression\nwhile (i < 5) {\n    print(result)\n# add break after 2 element \n  if (i==2){\n    break\n  }\n# update expression\n   i = i + 1\n   result = result + 1\n}\n\n[1] 1\n[1] 2\n\n\n\n\n\nA repeat loop is used to iterate over a block of code multiple number of times.\n\n# randomly draw values from a uniform distribution between 1 and 15.\nresult <- 1\nx <- NULL\n# random draws of values between 1 and 15 \nrepeat {\n        x <- c(x, round(runif(1, min = 1, max = 15)))\n       if(all(1:15 %in% x)) {\n# for exit the loop\n          break\n        }\nresult<- result + 1\n}\nresult\n\n[1] 46\n\n\n\n\n\n\nWriting custom functions is an important part of programming in R.\nTo create a new R function we need to think about 4 major things:\n\nthe name of the function\nthe arguments (inputs) the function will take\nthe code the function will run\nthe output the function will return for the user\n\nTo create a function, use the function() keyword:\n\n# create a function with the name my_function\nmy_function <- function() { \n  print(\"Hello World!\")\n}\n# call the function\nmy_function()\n\n[1] \"Hello World!\"\n\n\nArguments are specified after the function name, inside the parentheses. The following example has a function (full_name) with one arguments (last_name). When the function is called, we pass along a first name, which is used inside the function to print the full name:\n\nfulll_name <- function(last_name) {\n  paste(\"Zia\",  last_name)\n}\nfulll_name(\"Ahmed\")\n\n[1] \"Zia Ahmed\"\n\n\nTo return the results of a function, use the return() function:\n\naddition <- function(x) {\n  return (1 + x)\n}\nprint(addition(2))\n\n[1] 3\n\nprint(addition(3))\n\n[1] 4\n\n\nWe can create a simple equation with two arguments (x, y):\n\nequation <- function(x, y) {\n  a <- x + y\n  return(a)\n}\nequation(2,2)\n\n[1] 4\n\n\nWe can Call a function within another function:\n\nequation(equation(2,4), equation(3,3))\n\n[1] 12\n\n\n\nThe output above function is therefore (2+4) + (3+3) = 12.\n\nWe can also write a function within a function:\n\nx <- 10 \ny<- function() {\n        r <- 2\n        n <- 5\n        z <- function() {\n                (1+r)^n\n        }\n        x/z()\n}\ny()\n\n[1] 0.04115226\n\n\nReturning Multiple Outputs from a Function:\n\nresults_all <- function(x, y) {\n        results1 <- 2*x + y\n        results2 <- x + 2*y\n        results3 <- 2*x + 2*y\n        results4 <- x/y\n        c(results1, results2, results3, results4)\n}\nresults_all(1, 2)\n\n[1] 4.0 5.0 6.0 0.5\n\n\nFollowing function shows an example to convert temperature from Celsius (C) to Fahrenheit (F):\n\nC_to_F = function(C) {\n f = (9/5) * C + 32; # formula\n return(f); # return to\n}\nC_to_F(10)\n\n[1] 50\n\nC= c(4:10)\nC_to_F(C)\n\n[1] 39.2 41.0 42.8 44.6 46.4 48.2 50.0\n\n\n\n\n\nThe apply family consists of vectorized functions which minimize our need to explicitly create loops. These family is an inbuilt R package, so no need to install any packages for the execution.\n\napply() for matrices and data frames\nlapply() for lists…output as list\nsapply() for lists…output simplified\ntapply() for vectors\nmapply() for multi-variant\n\n\n\napply() returns a vector or array or list of values obtained by applying a function to margins of an array or matrix or dataframe. Using apply() is not faster than using a loop function, but it is highly compact and can be written in one line.\n\napply(x,MARGIN, FUN,…)\n\nWhere:\n\nx is the matrix, dataframe or array\nMARGIN is a vector giving the subscripts which the function will be applied over. E.g., for a matrix 1 indicates rows, 2 indicates columns, c(1, 2) indicates rows and columns.\nFUN is the function to be applied\n… is for any other arguments to be passed to the function\n\n\n# Crate a dataframe\ndf <- cbind(x1 = 1:8, x2 = 2:9, x3=3:10)\n# add row names\ndimnames(df)[[1]] <- letters[1:8] \n\nLet’s calculate column mean:\n\napply(df, 2, mean, trim = 0.2)\n\n x1  x2  x3 \n4.5 5.5 6.5 \n\n\nRow mean:\n\napply(df, 1, mean, trim = .2)\n\na b c d e f g h \n2 3 4 5 6 7 8 9 \n\n\nGet column quantile:\n\napply(df, 2, quantile, probs = c(0.10, 0.25, 0.50, 0.75, 0.90))\n\n      x1   x2   x3\n10% 1.70 2.70 3.70\n25% 2.75 3.75 4.75\n50% 4.50 5.50 6.50\n75% 6.25 7.25 8.25\n90% 7.30 8.30 9.30\n\n\n\n\n\nlapply() returns a list of the same length as X (list), each element of which is the result of applying FUN to the corresponding element of X. It loops over a list, iterating over each element in that list and then applies a function to each element of the list and finally returns a list (l stand for list).\n\nlapply(x, FUN, …)\n\nWhere:\n\nx is the list\nFUN is the function to be applied\n… is for any other arguments to be passed to the function\n\n\n# Create a list\nmylist<-list(A=matrix(1:9,nrow=3),B=1:5,C=c(8,5),  logic = c(TRUE,FALSE,FALSE,TRUE, TRUE))\nmylist\n\n$A\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n$B\n[1] 1 2 3 4 5\n\n$C\n[1] 8 5\n\n$logic\n[1]  TRUE FALSE FALSE  TRUE  TRUE\n\n\n\nlapply(mylist, mean)\n\n$A\n[1] 5\n\n$B\n[1] 3\n\n$C\n[1] 6.5\n\n$logic\n[1] 0.6\n\n\nYou can see how the results are saved as a list form. We can easily unlist the results:\n\nunlist(lapply(mylist,mean))\n\n    A     B     C logic \n  5.0   3.0   6.5   0.6 \n\n\n\n\n\nsapply() is a wrapper of lapply() to simplify the result to vector or matrix.\n\nsapply(mylist, mean)\n\n    A     B     C logic \n  5.0   3.0   6.5   0.6 \n\n\n\n\n\ntapply() is used to apply a function over subsets of a vector when a dataset can be broken up into groups (via categorical variables - aka factors)\n\nmy.df\n\n  ID Landcover Settlement  pH  SOC\n1  1 Grassland      FALSE 6.6 1.20\n2  2    Forest      FALSE 4.5 3.40\n3  3    Arable      FALSE 6.8 1.10\n4  4     Urban       TRUE 7.5 0.12\n\n\nWe can use tapply() to calculate mean values of pH an SOC for land cover\n\napply(my.df[4:5], 2, function(x) tapply(x, my.df$Landcover, mean))\n\n           pH  SOC\nArable    6.8 1.10\nForest    4.5 3.40\nGrassland 6.6 1.20\nUrban     7.5 0.12\n\n\n\n\n\nmapply() is a multivariate version of sapply(). mapply() applies FUN to the first elements of each … argument, the second elements, the third elements, and so on.\n\nlist( rep(2, 4), rep(3, 3), rep(4, 2))\n\n[[1]]\n[1] 2 2 2 2\n\n[[2]]\n[1] 3 3 3\n\n[[3]]\n[1] 4 4\n\n\nYou can see that the same function (rep) is being called repeatedly where the first argument (number vector) varies from 2 to 4, and the second argument (rep) varies from 4 to 2. Instead, you can use mapply()\n\nmapply(rep, 2:4, 4:2)\n\n[[1]]\n[1] 2 2 2 2\n\n[[2]]\n[1] 3 3 3\n\n[[3]]\n[1] 4 4\n\n\n\n\n\n\n\nAn Introduction to R - The Comprehensive R Archive\nR Introduction - W3Schools\nAn Introduction to R"
  }
]